"""
Results generated by FitGIFtoHBP.py are stored as list of dictionary.
This script read these results and plot some relevant quantities.
"""
import matplotlib
matplotlib.use('TkAgg')

import matplotlib.pyplot as plt
from matplotlib.font_manager import FontProperties

import numpy
import numpy as np

import cPickle as pickle
import gzip

import sys
sys.path.append('../')

import os
import collections

import argparse
parser = argparse.ArgumentParser(description='create Model Dict')
parser.add_argument('--run', action="store_true")
parser.add_argument('--writeh5', action="store_true")
args = parser.parse_args()

if args.run is True:
    import glob
    import bglibpy
    import re
    import h5py
    import traceback
    import numpy.random as random


error_labels = [
            'OK',
            'L non value encountered',
            'L did not converge',
            'L numerical instability',
            'V big drop due to exp',
            'No static threshold',
            'No dynamic threshold',
            'No spikes in dataset',
            'L singular matrix encountered',
            'No static threshold']


def adjust_spines(ax, spines, color='k', d_out=10, d_down=False):

    if d_down == False:
        d_down = d_out

    ax.set_frame_on(True)
    ax.patch.set_visible(False)

    for loc, spine in ax.spines.iteritems():
        if loc in spines:
            if loc == 'bottom':
                spine.set_position(('outward', d_down))  # outward by 10 points
            else:
                spine.set_position(('outward', d_out))  # outward by 10 points
            #spine.set_smart_bounds(True)
        else:
            spine.set_visible(False) # set_color('none') # don't draw spine

    # turn off ticks where there is no spine
    if 'left' in spines:
        ax.yaxis.set_ticks_position('left')

        if color is not 'k':

            ax.spines['left'].set_color(color)
            ax.yaxis.label.set_color(color)
            ax.tick_params(axis='y', colors=color)

    elif 'right' not in spines:
        # no yaxis ticks
        ax.yaxis.set_ticks([])

    if 'right' in spines:
        ax.yaxis.set_ticks_position('right')

        if color is not 'k':

            ax.spines['right'].set_color(color)
            ax.yaxis.label.set_color(color)
            ax.tick_params(axis='y', colors=color)

    if 'bottom' in spines:
        pass
        ax.xaxis.set_ticks_position('bottom')
        #ax.axes.get_xaxis().set_visible(True)

    else:
        # no xaxis ticks
        ax.xaxis.set_ticks([])
        ax.axes.get_xaxis().set_visible(False)


def grid_spec(fig=None, box=None, rows=1, columns=2,
                top_margin=0.05, bottom_margin=0.05,
                left_margin=0.05, right_margin=0.05,
                hspace=0.2, wspace=0.2,
                width_ratios=None, height_ratios=None):

    if box == None:
        box = {
            'left': 0.0,
            'bottom': 0.0,
            'top': 1.0,
            'right': 1.0}

    if width_ratios is None:
        width_ratios=[1]*columns

    if height_ratios is None:
        height_ratios=[1]*rows

    left = box['left'] + left_margin
    right = box['right'] - right_margin
    top = box['top'] - top_margin
    bottom= box['bottom'] + bottom_margin

    gs = matplotlib.gridspec.GridSpec(rows, columns,
                        height_ratios=height_ratios,
                        width_ratios=width_ratios)

    gs.update(top=top,
                bottom=bottom,
                left=left,
                right=right,
                hspace=hspace, wspace=wspace)

    return gs

def set_panels(axs, panels):

    if panels:
        font = FontProperties().copy()
        font.set_family('sans-serif')
        font.set_weight('bold')

        for il, label in enumerate(panels['labels']):
            if 'x' in panels:
                x = panels['x']
            else:
                x = -0.1

            if 'y' in panels:
                y = panels['y']
            else:
                y = 1.15

            axs[il].text(x, y, label,
                    fontsize=12, transform=axs[il].transAxes,
                    va='top', ha='right', fontproperties=font)


def set_fig_panels(fig, panels=False):

    if panels:
        font = FontProperties().copy()
        font.set_family('sans-serif')
        font.set_weight('bold')

        for label, (x, y) in panels.iteritems():
            plt.figtext(x, y, label,
                    fontsize=12, figure=fig,
                    va='top', ha='left', fontproperties=font)


def set_global_panels(fig, xys, panels=False):

    if panels:
        font = FontProperties().copy()
        font.set_family('sans-serif')
        font.set_weight('bold')

        for il, label in enumerate(panels['labels']):

            (x, y) = xys[il]

            if 'x' in panels:
                x_off = panels['x']
            else:
                x_off = 0

            if 'y' in panels:
                y_off = panels['y']
            else:
                y_off = 0

            plt.figtext(x+x_off, y+y_off, label,
                    fontsize=12, figure=fig,
                    va='bottom', ha='right', fontproperties=font)


def single_ax(d_out=0, panels=False, **kwargs):

    gs = grid_spec(rows=1, columns=1, **kwargs)

    ax = fig.add_subplot(g[0])
    xy = (g.get_position(fig).xmin, g.get_position(fig).ymax)
    adjust_spines(ax, ['left', 'bottom'], d_out=d_out)

    set_global_panels(fig, [xy], panels)

    return ax


def grid_axs(d_out=0, panels=False, **kwargs):

    axs = []
    xys = []

    gs = grid_spec(**kwargs)

    for g in gs:
        axs.append(fig.add_subplot(g))
        xys.append((g.get_position(fig).xmin, g.get_position(fig).ymax))
        adjust_spines(axs[-1], ['left', 'bottom'], d_out=d_out)

    set_global_panels(fig, xys, panels)

    return axs


def tiled_axs(frames=1, columns=2, d_out=0, panels=False, **kwargs):

    axs = []
    xys = []

    rows = int(numpy.ceil(frames/float(columns)))

    gs = grid_spec(rows=rows, **kwargs)

    for fi in range(frames):
        g = gs[int(fi/columns), int(fi%columns)]
        axs.append(fig.add_subplot(g))
        xys.append((g.get_position(fig).xmin, g.get_position(fig).ymax))
        adjust_spines(axs[-1], ['left', 'bottom'], d_out=d_out)

    set_global_panels(fig, xys, panels)

    return axs


def make_figure(figname='', figs=collections.OrderedDict(),
                dirname='', fontsizes=(6,8), figsize_mm=None,
                orientation ='landscape'):

    if figname not in figs.keys():

        if (orientation == 'landscape') and (figsize_mm == None):
            figsize_mm = (297, 210)
        elif (orientation == 'page') and (figsize_mm == None):
            figsize_mm = (210, 297)

        figsize = (figsize_mm[0]/25.4, figsize_mm[1]/25.4)

        params = {'backend': 'ps',
                  'axes.labelsize': fontsizes[0],
                  'axes.linewidth' : 0.5,
                  'font.size': fontsizes[1],
                  'axes.titlesize': fontsizes[1],
                  'legend.fontsize': fontsizes[1],
                  'xtick.labelsize': fontsizes[0],
                  'ytick.labelsize': fontsizes[0],
                  'legend.borderpad': 0.2,
                  'legend.loc': 'best',
                  'text.usetex': False,
                  'pdf.fonttype': 42,
                  'figure.figsize': figsize}
        matplotlib.rcParams.update(params)

        fig = plt.figure(figname, facecolor='white')
        figs[figname] = {}
        figs[figname]['fig'] = fig
        figs[figname]['dirname'] = dirname
        figs[figname]['axs'] = []

    return fig


b1 = '#1F78B4' #377EB8
b2 = '#A6CEE3'
g1 = '#33A02C' #4DAF4A
g2 = '#B2DF8A'
r1 = '#E31A1C' #E41A1C
r2 = '#FB9A99'
o1 = '#FF7F00' #FF7F00
o2 = '#FDBF6F'
p1 = '#6A3D9A' #984EA3
p2 = '#CAB2D6'

ye1 = '#FFFF33'
br1 = '#A65628'
br2 = '#D3865B'
pi1 = '#F781BF'
gr1 = '#999999'
k1 = '#000000'
pet1 = '#99D6BA'


def interpolateFilterExps(filter_param, tmax=1000.0, dt=1.0):

    support = np.arange(0, int(tmax/dt))*dt
    filter = np.zeros(len(support))
    for i in np.arange(filter_param[0]) :

        filter += np.exp(-support/filter_param[1][i])*filter_param[2][i]

    return (support, filter)


if __name__ == '__main__':

    result_path = "../../HBP_results/"
    plot_dict_path = result_path + "HBP_Model_fit_plot_dict.p"

    if (os.path.isfile(plot_dict_path)==False) or (args.run==True):

        quality_thresholds = {
                        'likelihood_testset': 2.,
                        'pct_var_explained_testset': 40.,
                        'DV': 2.
                        }

        plot_thresholds = {
                        'likelihood_testset': 0.,
                        'pct_var_explained_testset': 0.,
                        'DV': 3.
                        }

        ignore_fit_problems = True

        # get list of gid from files:
        base_dir = "/gpfs/bbp.cscs.ch/project/proj38/singlecell/tests/150413_simplification/simulation/ReNCCv2/syn_to_soma/ca_scan_long/soma_corr_fil_somacurr/"
        path = "K5p0/Ca1p25_1/h5_ready/"
        filepaths = glob.glob(base_dir + path + "a*.h5")
        gids = [int(re.match(".*\/a(\d*).h5", f).group(1)) for f in filepaths]

        print "Total number of cells: " + str(len(gids))

        # get all raw parameters
        results = np.load(result_path + "GIFparametersHBP.npy").item()

        # get information on circuit
        bluedir = "/gpfs/bbp.cscs.ch/project/proj1/simulations/"
        blueconfig0 = "ReNCCv2/" \
                      "ca_scan_40s/K5p0/Ca1p25/BlueConfig"
        blueconfig = bluedir + blueconfig0
        ssim = bglibpy.SSim(blueconfig)
        sim = ssim.bc_simulation

        etypes_names = sim.circuit.mvddb.etype_name2id_map()
        #mtypes = sim.circuit.mvddb.mtype_name2id_map()

        plot_dict = collections.OrderedDict()
        plot_dict['all'] = collections.OrderedDict()
        plot_dict['all']['L_test'] = []
        plot_dict['all']['Var_test'] = []
        plot_dict['all']['DV'] = []

        plot_dict['etypes'] = collections.OrderedDict()
        for etype_name in etypes_names:
            plot_dict['etypes'][etype_name] = collections.OrderedDict()
            plot_dict['etypes'][etype_name]['etas'] = []
            plot_dict['etypes'][etype_name]['gammas'] = []

            plot_dict['etypes'][etype_name]['C'] = []
            plot_dict['etypes'][etype_name]['El'] = []
            plot_dict['etypes'][etype_name]['gl'] = []
            plot_dict['etypes'][etype_name]['T_ref'] = []
            plot_dict['etypes'][etype_name]['Vt_star'] = []
            plot_dict['etypes'][etype_name]['Vr'] = []
            plot_dict['etypes'][etype_name]['DV'] = []
            plot_dict['etypes'][etype_name]['lambda0'] = []

            plot_dict['etypes'][etype_name]['tau_eta'] = []
            plot_dict['etypes'][etype_name]['a_eta'] = []

            plot_dict['etypes'][etype_name]['tau_gamma'] = []
            plot_dict['etypes'][etype_name]['a_gamma'] = []

            plot_dict['etypes'][etype_name]['L'] = []
            plot_dict['etypes'][etype_name]['Var'] = []

        # note all possible metype combinations
        metypes = []
        # save all failed fits
        failed_gids = []

        # save results of fits for all succesful gids.
        # add replacements later for unsuccessful fits!
        gids_dict = collections.OrderedDict()

        # save gids of succesful fits ordered by metype.
        metypes_success_index = collections.OrderedDict()
        mtypes_success_index = collections.OrderedDict()
        etypes_success_index = collections.OrderedDict()

        # save gids of all cells.
        metypes_all_index = collections.OrderedDict()

        gids_to_metype_dict = collections.OrderedDict()


        for gid in gids:
            neuron = sim.circuit.mvddb.load_gids([gid], pbar=False)[0]
            if neuron.gid == gid:
                mtype = str(neuron.mtype_id)
                etype = str(neuron.etype_id)
                etype_name = neuron.etype.name

                metype_str = mtype + "_" + etype
                metype_tup = (mtype, etype)
                gids_to_metype_dict[gid] = metype_tup

                if metype_tup not in metypes:
                    metypes.append(metype_tup)
                    metypes_success_index[metype_str] = []
                    metypes_all_index[metype_str] = []

                if mtype not in mtypes_success_index:
                    mtypes_success_index[mtype] = []

                if etype not in etypes_success_index:
                    etypes_success_index[etype] = []

                metypes_all_index[metype_str].append(gid)

                try:
                    r = results[gid].item()

                    # check if no exception occured
                    if ignore_fit_problems or (r['fit_problem'] == False):

                        if (r['likelihood_testset'] > plot_thresholds['likelihood_testset'] and
                                r['pct_var_explained_testset'] > plot_thresholds['pct_var_explained_testset'] and
                                r['model']['DV'] < plot_thresholds['DV']):

                            plot_dict['all']['L_test'].append(r['likelihood_testset'])
                            plot_dict['all']['Var_test'].append(r['pct_var_explained_testset'])
                            plot_dict['all']['DV'].append(r['model']['DV'])


                        # check if quality is high enough
                        if (r['likelihood_testset'] >= quality_thresholds['likelihood_testset'] and
                                r['pct_var_explained_testset'] >= quality_thresholds['pct_var_explained_testset'] and
                                r['model']['DV'] < quality_thresholds['DV']):

                            metypes_success_index[metype_str].append(gid)
                            mtypes_success_index[mtype].append(gid)
                            etypes_success_index[etype].append(gid)

                            # add succesful gid
                            gids_dict[gid] = r

                            (tgamma, gamma) = interpolateFilterExps(r['model']['gamma'])
                            (teta, eta) = interpolateFilterExps(r['model']['eta'])

                            plot_dict['teta'] = teta
                            plot_dict['tgamma'] = tgamma

                            plot_dict['etypes'][etype_name]['etas'].append(eta)
                            plot_dict['etypes'][etype_name]['gammas'].append(gamma)

                            plot_dict['etypes'][etype_name]['C'].append(r['model']['C'])
                            plot_dict['etypes'][etype_name]['El'].append(r['model']['El'])
                            plot_dict['etypes'][etype_name]['gl'].append(r['model']['gl'])
                            plot_dict['etypes'][etype_name]['T_ref'].append(r['model']['T_ref'])
                            plot_dict['etypes'][etype_name]['Vt_star'].append(r['model']['Vt_star'])
                            plot_dict['etypes'][etype_name]['Vr'].append(r['model']['Vr'])
                            plot_dict['etypes'][etype_name]['DV'].append(r['model']['DV'])
                            plot_dict['etypes'][etype_name]['lambda0'].append(r['model']['lambda0'])

                            plot_dict['etypes'][etype_name]['L'].append(r['likelihood_testset'])
                            plot_dict['etypes'][etype_name]['Var'].append(r['pct_var_explained_testset'])


                            n_eta = r['model']['eta'][0]
                            tau_eta = numpy.empty(3) * np.nan
                            a_eta = numpy.empty(3) * np.nan
                            for ie in range(n_eta):
                                tau_eta[ie] = r['model']['eta'][1][ie]
                                a_eta[ie] = r['model']['eta'][2][ie]

                            plot_dict['etypes'][etype_name]['tau_eta'].append(tau_eta)
                            plot_dict['etypes'][etype_name]['a_eta'].append(a_eta)

                            n_gamma = r['model']['gamma'][0]
                            tau_gamma = numpy.empty(3) * np.nan
                            a_gamma = numpy.empty(3) * np.nan
                            for ie in range(n_gamma):
                                tau_gamma[ie] = r['model']['gamma'][1][ie]
                                a_gamma[ie] = r['model']['gamma'][2][ie]

                            plot_dict['etypes'][etype_name]['tau_gamma'].append(tau_gamma)
                            plot_dict['etypes'][etype_name]['a_gamma'].append(a_gamma)

                        else:
                            failed_gids.append(gid)
                            # print (str(gid) + " quality check failed! with"
                            #                 + " " + str(r['likelihood_testset'])
                            #                 + " " + str(r['pct_var_explained_testset'])
                            #                 + " " + str(r['model']['DV']))

                    else:
                        failed_gids.append(gid)
                        # print str(gid) + " fit problem!"

                except:
                    e = sys.exc_info()[0]
                    print "".join(traceback.format_exception(*sys.exc_info()))

                    failed_gids.append(gid)
                    # print str(gid) + " exception!"

            else:
                raise ValueError('Given gid was not requested!')

        for etype, etype_dict in plot_dict['etypes'].iteritems():
            for param, paramlist in etype_dict.iteritems():
                etype_dict[param] = [numpy.nanmean(paramlist, axis=0), numpy.nanstd(paramlist, axis=0)]

        print "There are " + str(len(metypes)) + " different metypes."

        print "Number of failed cells: " + str(len(failed_gids))

        for metype_tup in metypes:
            metype_str = metype_tup[0] + "_" + metype_tup[1]

            n_success = len(metypes_success_index[metype_str])
            n_total = len(metypes_all_index[metype_str])
            p_success = n_success/float(n_total) * 100.

            print ("for " + metype_str + " there are " +
                    str(n_success) + " succesful cells of " +
                    str(n_total) + " in total = " +
                    str(p_success) + "% success")

        # replace failed cells:
        for gid in failed_gids:
            metype_tup = gids_to_metype_dict[gid]
            metype_str = metype_tup[0] + "_" + metype_tup[1]
            alternative_gids = metypes_success_index[metype_str]

            if len(alternative_gids) == 0:
                print ("failed cell " + str(gid) + " not enough" +
                        " alternative cells for metype " + metype_str +
                        " using another random mtype")
                alternative_gids = mtypes_success_index[metype_tup[0]]

            random.seed(gid)
            random.shuffle(alternative_gids)

            alt_gid = alternative_gids[0]

            alt_metype_tup = gids_to_metype_dict[alt_gid]
            alt_metype_str = alt_metype_tup[0] + "_" + alt_metype_tup[1]

            gids_dict[gid] = gids_dict[alt_gid]

        print ("Number of cells simplified:" + str(len(gids_dict.items())))

        if (len(gids_dict.items()) != len(gids)):
            raise ValueError('Not all cells accounted for!')

        if args.writeh5:

            with h5py.File(result_path + 'gif_params' + '.h5', 'w') as f:

                for gid, gid_dict in gids_dict.iteritems():

                    model = gid_dict['model']

                    C = model['C']
                    El = model['El']
                    gl = model['gl']
                    T_ref = model['T_ref']
                    Vt_star = model['Vt_star']
                    Vr = model['Vr']
                    DV = model['DV']
                    lambda0 = model['lambda0']

                    n_eta = model['eta'][0]
                    if n_eta > 3:
                        raise Exception("Number of filter coefficients too large "
                                        "only 3 coefficients implemented in NEURON")

                    if n_eta >= 1:
                        tau_eta1 = model['eta'][1][0]
                        a_eta1 = model['eta'][2][0]
                    else:
                        tau_eta1 = 1
                        a_eta1 = 0

                    if n_eta >= 2:
                        tau_eta2 = model['eta'][1][1]
                        a_eta2 = model['eta'][2][1]
                    else:
                        tau_eta2 = 1
                        a_eta2 = 0

                    if n_eta >= 3:
                        tau_eta3 = model['eta'][1][2]
                        a_eta3 = model['eta'][2][2]
                    else:
                        tau_eta3 = 1
                        a_eta3 = 0

                    n_gamma = model['gamma'][0]
                    if n_gamma > 3:
                        raise Exception("Number of filter coefficients too large "
                                        "only 3 coefficients implemented in NEURON")

                    if n_gamma >= 1:
                        tau_gamma1 = model['gamma'][1][0]
                        a_gamma1 = model['gamma'][2][0]
                    else:
                        tau_gamma1 = 1
                        a_gamma1 = 0

                    if n_gamma >= 2:
                        tau_gamma2 = model['gamma'][1][1]
                        a_gamma2 = model['gamma'][2][1]
                    else:
                        tau_gamma2 = 1
                        a_gamma2 = 0

                    if n_gamma >= 3:
                        tau_gamma3 = model['gamma'][1][2]
                        a_gamma3 = model['gamma'][2][2]
                    else:
                        tau_gamma3 = 1
                        a_gamma3 = 0

                    dataset = np.array([
                                C, El, gl, T_ref, Vt_star, Vr, DV, lambda0,
                                tau_eta1, tau_eta2, tau_eta3,
                                a_eta1, a_eta2, a_eta3,
                                tau_gamma1, tau_gamma2, tau_gamma3,
                                a_gamma1, a_gamma2, a_gamma3,
                                ])

                    f.create_dataset('a'+str(gid), data=dataset)

                print ("Number of parameters: " + str(len(dataset)))

        pickle.dump(plot_dict, open(plot_dict_path, "wb"))

    else:
        plot_dict = pickle.load(open(plot_dict_path, "rb"))

    # PLOT
    figs = {}
    fig = make_figure('gif_models', figs, dirname=result_path, fontsizes=(6,6), figsize_mm=(180,180))

    # QUALITY PLOTS
    box = {'left': 0.0, 'bottom': 0.8, 'top': 1.0, 'right': 1.0}
    panels={'x':0, 'y':0, 'labels':['A1','A2','A3']}
    #set_fig_panels(fig, {'A1':(0.05,0.98), 'A2':(0.35,0.98), 'A3':(0.7,0.98)})

    qual_axs = grid_axs(d_out=7, panels=panels, fig=fig, box=box, rows=1, columns=3,
                        top_margin=0.05, bottom_margin=0.05,
                        left_margin=0.05, right_margin=0.05,
                        hspace=0.2, wspace=0.2)

    bins = 100

    qual_axs[0].hist(plot_dict['all']['L_test'], bins=bins, range=(0,11), color=o1, histtype='stepfilled')
    qual_axs[0].set_xlabel('Likelihood (bits/spike)')
    qual_axs[0].set_yticks([0,300,600])
    qual_axs[0].set_ylim((0,800))

    qual_axs[1].hist(plot_dict['all']['Var_test'], bins=bins, range=(0,100), color=o1, histtype='stepfilled')
    qual_axs[1].set_xlabel(r'$\epsilon_V$ (%)')
    qual_axs[1].set_yticks([0,500,1000])
    qual_axs[1].set_ylim((0,1400))

    qual_axs[2].hist(plot_dict['all']['DV'], bins=bins, range=(0,1.5), color=o1, histtype='stepfilled')
    qual_axs[2].set_xlabel(r'$\Delta V$')
    qual_axs[2].set_yticks([0,500,1000])
    qual_axs[2].set_ylim((0,1400))


    # PARAM PLOTS
    box = {'left': 0.0, 'bottom': 0.0, 'top': 0.8, 'right': 0.7}
    panels={'x':0, 'y':0, 'labels':['B1']}

    param_axs = grid_axs(d_out=0, panels=panels, fig=fig, box=box, rows=1, columns=8,
                        top_margin=0.04, bottom_margin=0.07,
                        left_margin=0.07, right_margin=0.02,
                        hspace=0.4, wspace=0.2)

    etype_names = plot_dict['etypes'].keys()
    etype_names = ['cADpyr', 'cACint', 'cNAC', 'cSTUT', 'cIR', 'bAC', 'bNAC', 'bSTUT', 'bIR', 'dNAC', 'dSTUT'][::-1]

    params_list = ['C', 'El', 'gl', 'Vt_star', 'Vr', 'DV', 'L', 'Var']
    param_labels_list = ['C (nF)', r'$E_L$ (mV)', r'$g_L$ (uS)', r'$V_T^*$ (mV)', r'$V_{reset}$ (mV)', r'$\Delta V$ (mV)', 'L (bits/spike)', r'$\epsilon_V$ (%)']
    param_minmax = [(0,0.35), (-82.,-64.), (0,0.025), (-65,-56), (-80,-50), (0,1.6), (2,9), (60,100)]
    param_ticks = [[0.1,0.3], [-80,-70.], [0,0.02], [-64,-58], [-75,-55],
                    [0.4,1.2], [4,8], [70,100]]

    for ip, param in enumerate(params_list):
        for ie, etype_name in enumerate(etype_names):
            par_mean = plot_dict['etypes'][etype_name][param][0]
            par_std = plot_dict['etypes'][etype_name][param][1]
            param_axs[ip].errorbar(par_mean, ie, xerr=par_std, marker='o',
                            color=o1, markersize=4, clip_on=False)

            if ip == 0:
                adjust_spines(param_axs[ip], ['left', 'bottom'], d_out=5)
                param_axs[ip].yaxis.set_ticks(range(len(etype_names)))
                param_axs[ip].set_yticklabels(etype_names)
            else:
                adjust_spines(param_axs[ip], ['bottom'], d_out=5)

            param_axs[ip].set_ylim(-0.5, len(etype_names)-0.5)

            param_axs[ip].set_xticks(param_ticks[ip])
            param_axs[ip].set_xlim(param_minmax[ip])
            param_axs[ip].set_xlabel(param_labels_list[ip])
            #param_axs[ip].set_clip_on(False)

    # FILTER PLOTS
    box = {'left': 0.7, 'bottom': 0.0, 'top': 0.8, 'right': 1.0}
    panels={'x':0, 'y':0.01, 'labels':['B2']}

    clip_on = True

    x_minmax = (-10,200)
    x_ticks = [0,100,200]

    #y_minmax_eta = [ (-0.05,0.4),  (-0.02,0.25), (-0.01,0.2), (-0.05,0.2), (-0.02,0.08), (-0.02,0.08)
    #y_ticks_eta = [  [0,0.2,0.4],  [0,0.1,0.2],  [0,0.1,0.2], [0,0.1,0.2], [0,0.04,0.08]
    y_minmax_eta = (-0.05,0.25)
    y_ticks_eta = [0,0.2]
    #y_minmax_eta = False
    #y_ticks_eta = False

    #y_minmax_gamma = (-20,20)
    #y_ticks_gamma = [-20,0,20]

    y_minmax_gamma = [ (-1,1),   (-2,2),   (-200,200),   (-2,2),   (-20,20),
                       (-50e3,50e3),    (-400,400),   (-4,4),   (-1.3e10,1.3e10),
                       (-1.3e15,1.3e15),   (-1.3e15,1.3e15) ]
    y_ticks_gamma = [  [-0.5,0,0.5], [-1,0,1], [-100,0,100], [-1,0,1], [-10,0,10],
                       [-20e3,0,20e3], [-200,0,200], [-2,0,2], [-1e10,0,1e10],
                       [-1e15,0,1e15], [-1e15,0,1e15] ]

    y_labels_gamma = [  ['-0.5','','0.5'], ['-1','','1'], ['-100','','100'], ['-1','','1'], ['-10','','10'],
                       ['-2e4','','2e4'], ['-200','','200'], ['-2','','2'], ['-1e10','','1e10'],
                       ['-1e15','','1e15'], ['-1e15','','1e15'] ]

    #y_minmax_gamma = False
    #y_ticks_gamma = False

    filter_axs = grid_axs(d_out=0, panels=panels, fig=fig, box=box, rows=11, columns=2,
                        top_margin=0.05, bottom_margin=0.08,
                        left_margin=0.03, right_margin=0.02,
                        hspace=0.3, wspace=0.5)

    teta = plot_dict['teta']
    tgamma = plot_dict['tgamma']

    i_max = 2*len(etype_names)-1
    for ie, etype_name in enumerate(etype_names):

        i_gamma = 2*ie+1
        i_eta = 2*ie

        etas = plot_dict['etypes'][etype_name]['etas'][0]
        etas_std = plot_dict['etypes'][etype_name]['etas'][1]
        filter_axs[i_eta].plot(teta, etas, color=o1, clip_on=clip_on)
        filter_axs[i_eta].plot(teta, etas-etas_std, color=gr1, clip_on=clip_on)
        filter_axs[i_eta].plot(teta, etas+etas_std, color=gr1, clip_on=clip_on)
        filter_axs[i_eta].fill_between(teta, etas-etas_std, etas+etas_std, color=gr1, clip_on=clip_on)

        filter_axs[i_eta].set_xlim(x_minmax)

        if i_eta == i_max-1:
            adjust_spines(filter_axs[i_eta], ['left', 'bottom'], d_out=4, d_down=10)
            filter_axs[i_eta].set_xticks(x_ticks)
            filter_axs[i_eta].set_xlabel('ms')
        else:
            adjust_spines(filter_axs[i_eta], ['left'], d_out=4, d_down=10)

        if i_eta == 0:
            filter_axs[i_eta].set_title(r'$\eta(t)$ (nA)')

        if y_minmax_eta:
            filter_axs[i_eta].set_ylim(y_minmax_eta)
        if y_ticks_eta:
            filter_axs[i_eta].set_yticks(y_ticks_eta)


        gammas = plot_dict['etypes'][etype_name]['gammas'][0]
        gammas_std = plot_dict['etypes'][etype_name]['gammas'][1]
        filter_axs[i_gamma].plot(tgamma, gammas, color=o1, clip_on=clip_on)
        filter_axs[i_gamma].plot(tgamma, gammas-gammas_std, color=gr1, clip_on=clip_on)
        filter_axs[i_gamma].plot(tgamma, gammas+gammas_std, color=gr1, clip_on=clip_on)
        filter_axs[i_gamma].fill_between(tgamma, gammas-gammas_std, gammas+gammas_std, color=gr1, clip_on=clip_on)

        filter_axs[i_gamma].set_xlim(x_minmax)

        if i_gamma == i_max:
            adjust_spines(filter_axs[i_gamma], ['left', 'bottom'], d_out=4, d_down=10)
            filter_axs[i_gamma].set_xticks(x_ticks)
            filter_axs[i_gamma].set_xlabel('ms')
        else:
            adjust_spines(filter_axs[i_gamma], ['left'], d_out=4, d_down=10)

        if i_gamma == 1:
            filter_axs[i_gamma].set_title(r'$\gamma(t)$ (mV)')

        if y_minmax_gamma:
            filter_axs[i_gamma].set_ylim(y_minmax_gamma[ie])
        if y_ticks_gamma:
            filter_axs[i_gamma].set_yticks(y_ticks_gamma[ie])
            filter_axs[i_gamma].set_yticklabels(y_labels_gamma[ie])

    fig.savefig(result_path + 'Figure_GIF_Comparison.pdf', dpi=300)

    #plt.show()
